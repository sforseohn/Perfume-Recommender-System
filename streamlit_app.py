# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u_HyMV2qGegZUgr7yD0rDx5p1jqLCnk-
"""

# í†µí•©ëœ í•˜ì´ë¸Œë¦¬ë“œ í–¥ìˆ˜ ì¶”ì²œ ì‹œìŠ¤í…œ (FAISS + Neo4j + í‰ê°€ + Streamlit)

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sentence_transformers import SentenceTransformer
from sklearn.metrics import precision_score, recall_score
import faiss
import random
from collections import defaultdict
from neo4j import GraphDatabase
import streamlit as st

# ------------------------
# ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬
# ------------------------
csv_url = "https://raw.githubusercontent.com/rawanalqarni/Perfumes_Recommender/main/Datasets/Perfume_Dataset.csv"
df = pd.read_csv(csv_url)
df = df[['Name', 'Description','Top_note', 'Middle_note', 'Base_note']].fillna('')

# TF-IDF ë²¡í„°í™”
vectorizer = TfidfVectorizer()
top_vec = vectorizer.fit_transform(df['Top_note']).toarray()
middle_vec = vectorizer.fit_transform(df['Middle_note']).toarray()
base_vec = vectorizer.fit_transform(df['Base_note']).toarray()

max_dim = max(top_vec.shape[1], middle_vec.shape[1], base_vec.shape[1])
pad = lambda arr, dim: np.pad(arr, ((0, 0), (0, dim - arr.shape[1])), 'constant')
top_vec = pad(top_vec, max_dim)
middle_vec = pad(middle_vec, max_dim)
base_vec = pad(base_vec, max_dim)

note_vectors = (0.3 * top_vec + 0.5 * middle_vec + 0.2 * base_vec).astype('float32')

# SBERT ì„ë² ë”©
desc_model = SentenceTransformer('paraphrase-MiniLM-L3-v2')
desc_vecs = desc_model.encode(df['Description'].tolist(), normalize_embeddings=True)

combined = np.hstack([note_vectors, desc_vecs]).astype('float32')
faiss.normalize_L2(combined)

# FAISS ì¸ë±ìŠ¤
index = faiss.IndexFlatIP(combined.shape[1])
index.add(combined)

# FAISS ê¸°ë°˜ ì¶”ì²œ
def recommend_perfumes_faiss(user_id, top_k=30):
    liked = get_user_liked_perfumes(user_id)
    liked_idxs = [df[df['Name'] == p].index[0] for p in liked if p in df['Name'].values]
    if not liked_idxs:
        return []
    query = np.mean([combined[i] for i in liked_idxs], axis=0).reshape(1, -1)
    faiss.normalize_L2(query)
    _, idxs = index.search(query, top_k)
    recs = [df.iloc[i]['Name'] for i in idxs[0]]
    #return [r for r in recs if r not in liked]
    return [r for r in recs]

# ì‚¬ìš©ì ìƒì„± ë° ìœ ì‚¬ ì‚¬ìš©ì ê¸°ë°˜ ì¶”ì²œ (Neo4j)
user_ids = [f"user_{i}" for i in range(1, 501)]
uri = "neo4j+s://c5aa6fa9.databases.neo4j.io"
username = "neo4j"
password = "lqdv0Rvs20n5MOUdonw39z15fyM6CPagVtc18vxzbmw"

def get_user_liked_perfumes(user_id):
    query = """
    MATCH (u:User {userId: $user_id})-[:LIKES]->(p:Perfume)
    RETURN p.name AS perfume_name
    """

    with GraphDatabase.driver(uri, auth=(username, password)).session() as session:
        result = session.run(query, user_id=user_id)
        return [record["perfume_name"] for record in result]

def get_recommendations_for_user(user_id):
    query = """
    MATCH (me:User {userId: $user_id})-[:LIKES]->(p1)<-[:LIKES]-(other:User)-[:LIKES]->(p2)
    RETURN p2.name AS perfume_name, COUNT(DISTINCT other) AS score
    ORDER BY score DESC
    """

    with GraphDatabase.driver(uri, auth=(username, password)).session() as session:
        result = session.run(query, user_id=user_id)
        return pd.DataFrame([r.data() for r in result])

# í•˜ì´ë¸Œë¦¬ë“œ ì¶”ì²œ
def get_hybrid_recommendations(user_id, top_k=10, alpha=0.5, exclude_liked=False):
    content_recs = recommend_perfumes_faiss(user_id, top_k=30)
    collab_df = get_recommendations_for_user(user_id)
    content_score = {p: 30 - i for i, p in enumerate(content_recs)}
    collab_score = {row['perfume_name']: row['score'] for _, row in collab_df.iterrows()}
    all_names = set(content_score) | set(collab_score)
    liked = get_user_liked_perfumes(user_id)
    hybrid_scores = {n: alpha * content_score.get(n, 0) + (1 - alpha) * collab_score.get(n, 0) for n in all_names}
    sorted_perfumes = sorted(hybrid_scores.items(), key=lambda x: x[1], reverse=True)
    recs = [name for name, _ in sorted_perfumes if not exclude_liked or name not in liked]
    return recs[:top_k]

# í‰ê°€ ì§€í‘œ ê³„ì‚°
def evaluate_user(gt, pred, all_items, popularity_dict):
    y_true = [1 if i in gt else 0 for i in all_items]
    y_pred = [1 if i in pred else 0 for i in all_items]
    precision = precision_score(y_true, y_pred, zero_division=0)
    recall = recall_score(y_true, y_pred, zero_division=0)
    novelty = np.mean([-np.log2((popularity_dict.get(p, 0) + 1) / len(user_ids)) for p in pred])
    return precision, recall, novelty

# Streamlit ì¸í„°í˜ì´ìŠ¤
st.set_page_config(page_title="í–¥ìˆ˜ ì¶”ì²œ ì‹œìŠ¤í…œ", layout="wide")
st.title("ğŸŒ¸ í•˜ì´ë¸Œë¦¬ë“œ í–¥ìˆ˜ ì¶”ì²œ ì‹œìŠ¤í…œ")

selected_user = st.selectbox("ì‚¬ìš©ìë¥¼ ì„ íƒí•˜ì„¸ìš”", user_ids)
top_k = st.slider("Top-K ì¶”ì²œ ê°œìˆ˜", 5, 30, 10)
alpha = st.slider("ì½˜í…ì¸  ê¸°ë°˜ ê°€ì¤‘ì¹˜ (0=í˜‘ì—…, 1=ì½˜í…ì¸ )", 0.0, 1.0, 0.5)

if st.button("ì¶”ì²œ ë°›ê¸°"):
    recs = get_hybrid_recommendations(selected_user, top_k=top_k, alpha=alpha)
    st.subheader(f"ì¶”ì²œ í–¥ìˆ˜ ë¦¬ìŠ¤íŠ¸ (User: {selected_user})")
    st.write(recs)

    # í‰ê°€ ê²°ê³¼ë„ í•¨ê»˜ ì¶œë ¥
    gt = get_user_liked_perfumes(selected_user)
    all_perfumes = df['Name'].tolist()
    perfume_popularity = {name: 1 for name in all_perfumes}  # ê°„ë‹¨í•œ ì˜ˆì‹œìš©
    precision, recall, novelty = evaluate_user(gt, recs, all_perfumes, perfume_popularity)
    st.markdown("### ğŸ“Š í‰ê°€ ì§€í‘œ")
    st.markdown(f"**Precision:** {precision:.3f}")
    st.markdown(f"**Recall:** {recall:.3f}")
    st.markdown(f"**Novelty:** {novelty:.3f}")